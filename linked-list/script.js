class SinglyLinkedListItem {
  constructor(value) {
    this.value = value;
    this.next = null;
  }
}

export class SinglyLinkedList {
  constructor() {
    this.head = null;
    this.length = 0;
  }

  get size() {
    return this.length;
  }

  get isEmpty() {
    if (this.length === 0) {
      return true;
    } else {
      return false;
    }
  }


  // ===================================================================
  // Добавить узлы в конец списка
  // ===================================================================
  append(...values) {
    values.forEach(item => {
      // 1. Создать экземпляр узла
      let newNode = new SinglyLinkedListItem(item);

      // 2. Если список пустой
      if (this.head === null) {
        // 2.1. Созданный узел сделать "головным"
        this.head = newNode;
      }
      // 3. Иначе (если список не пустой)
      else {
        // 3.1. Головной объект сделать текущим
        let currentNode = this.head;
        // 3.2. Пока у текущего узла есть ссылка на следующий узел...
        while (currentNode.next !== null) {
          // 3.3. Делать следующий узел текущим (так дойдёт до последнего узла)
          currentNode = currentNode.next
        }
        // 3.4. Когда "текущий" узел дойдёт до последнего, добавить ещё один узел
        currentNode.next = newNode
      }

      // 4. Увеличить длину списка на 1
      this.length++;
    });
  }


  // ===================================================================
  // Получить значение узла с указанным индексом
  // ===================================================================
  at(index) {
    // 1. Если список пустой
    if (this.head === null) {
      // 1.1. Нечего искать, поэтому вернуть "null"
      return undefined;
    }
    
    // 2. Если список не пустой
    // 2.1. Головной объект сделать текущим
    let currentNode = this.head;
    // 2.2. Счётчик узлов. Начальное значение
    let count = 0;
    // 2.3. Пока счётчик меньше нужного индекса
    while (count <= index) {
      // 2.4. Если счётчик дошёл до искомого индекса, вернуть значение
      if (count === index) return currentNode.value;

      // 2.5. Если у текущего элемента нет ссылки на следующий узел, значит
      // .... закончились узлы, не дойдя до нужного индекса
      if (currentNode.next === null) return undefined;
      
      // 2.6. Сделать следующий узел текущим (пока не дойдёт до нужного индекса)
      currentNode = currentNode.next;
      // 2.7. Увеличить индекс на 1
      count++;
    }
  }


  // ===================================================================
  // Очистить список
  // ===================================================================
  clear() {
    // 1. Очистить "головной" узел (автоматически удалятся остальные узлы)
    this.head = null;

    // 2. Длину узла установить на "0
    this.length = 0;

    // 3. Вернуть новую длину списка
    return this.length;
  }


  // ===================================================================
  // Проверить наличие узла с указанным значением
  // ===================================================================
  contains(value) {
    // 1. Если список пустой, нечего искать, поэтому вернуть "false"
    if (this.head === null) return false;

    // 2. Если список не пустой
    // 2.1. "Головной" узел сделать текущим (с него будет начинаться перебор)
    let currentNode = this.head;
    // 2.2. Пока текущий узел существует (не равен "null")
    while (currentNode !== null) {
      // 2.3. Если текущий узел имеет искомое значение, вернуть "true"
      if (currentNode.value === value) return true;

      // 2.4. Если следующего узла нет, вернуть "false"
      if (currentNode.next === null) return false;

      // 2.5. Иначе следующий узел сделать текущим
      currentNode = currentNode.next;
    }
  }


  // ===================================================================
  // Найти узел с указанным значением и вернуть индекс
  // ===================================================================
  indexOf(value) {
    // 1. Если список пустой, нечего искать, поэтому вернуть "false"
    if (this.head === null) return false;

    // 2. Если список не пустой
    // 2.1. "Головной" узел сделать текущим (с него будет начинаться перебор)
    let currentNode = this.head;
    // 2.2. Счётчик узлов. Начальное значение
    let count = 0;
    // 2.2. Пока текущий узел существует (не равен "null")
    while (currentNode !== null) {
      // Если текущий узел имеет искомое значение, вернуть индекс
      if (currentNode.value === value) return count;

      // Если следующего узла нет, такого значения нет (вернуть "-1")
      if (currentNode.next === null) return -1;

      // Иначе следующий узел сделать текущим
      currentNode = currentNode.next;
      count++;
    }
  }


  // ===================================================================
  // Найти узел с указанным значением и вернуть индекс
  // ===================================================================
  indexOf(value) {
    // 1. Если список пустой, нечего искать, поэтому вернуть "false"
    if (this.head === null) return false;

    // 2. Если список не пустой
    // 2.1. "Головной" узел сделать текущим (с него будет начинаться перебор)
    let currentNode = this.head;
    // 2.2. Счётчик узлов. Начальное значение
    let count = 0;

    // 3. Пока текущий узел существует (не равен "null")
    while (currentNode !== null) {
      // 3.1. Если текущий узел имеет искомое значение, вернуть индекс
      if (currentNode.value === value) return count;

      // 3.2. Если следующего узла нет, такого значения нет (вернуть "-1")
      if (currentNode.next === null) return -1;

      // 3.3. Иначе следующий узел сделать текущим
      currentNode = currentNode.next;
      count++;
    }
  }


  // ===================================================================
  // Добавить узел в указанном месте
  // ===================================================================
  insert(index, value) {
    // 1. Создать новый узел
    const newNode = new SinglyLinkedListItem(value);

    // 1. Если список пустой, добавить элемент в конец (append)
    if (this.head === null) {
      this.append(value);
      return;
    }

    // 1. Если нужно добавить на первое место, использовать "prepend"
    if (index === 0) {
      this.prepend(value);
      return;
    }
    
    // 2."Головной" узел сделать текущим (с него будет начинаться перебор)
    let currentNode = this.head;
    let count = 0;

    // 3. Пока текущий узел существует (не равен "null")
    while (currentNode !== null) {
      // 3.1. Если "count" равен искомому индексу, 
      if (count === index - 1) {
        // 3.2. Новому узлу добавить ссылку на следующий узел
        newNode.next = currentNode.next;

        // 3.3. Текущему узлу добавить ссылку на новый узел
        currentNode.next = newNode;

        // 3.4. Увеличить длину списка
        this.length++;
        
        // 3.4. Вернуть новую длину списка
        return this.length;
      }
      
      // 4. Если следующего узла нет, значит такого индекса нет (вернуть список)
      if (currentNode.next === null) return false;

      // 5. Иначе следующий узел сделать текущим
      currentNode = currentNode.next;
      count++;
    }
  }


  // ===================================================================
  // Добавить узел в начало списка
  // ===================================================================
  prepend(value) {
    // 1. Создать новый узел
    const newNode = new SinglyLinkedListItem(value);

    // 2. Новому узлу задать ссылку на текущий "головной" элемент
    newNode.next = this.head;

    // 3. Сделать новый элемент "головным"
    this.head = newNode;

    // 4. Увеличить длину массива
    this.length++;

    // 5. Вернуть новую длину массива
    return this.length
  }


  // ===================================================================
  // Удалить узел с заданным индексом
  // ===================================================================
  remove(index) {
    // 4. Иначе
    let prevNode = null;
    let currentNode = this.head;
    let deletedNode = null;

    // 1. Если список пустой, нечего удалять
    if (this.head === null) return undefined;

    // 2. Нельзя передавать индекс меньше нуля или больше длины списка
    if (index < 0 || index >= this.length) return undefined;

    // 3. Если в списке один элемент, значит это "головной" и его удалить
    if (this.length === 1) {
      deletedNode = this.head;
      this.head = null;
      this.length--;
      return deletedNode.value;
    }

    // 3. Пока очередной текущий узел существует (не равен "null")
    let count = 0;
    while (currentNode !== null) {
      // 4.1. Если удаляется первый узел, после которого нет узла
      if (count === index && count === 0 && currentNode.next === null) {
        // Сохранить удаляемый узел
        deletedNode = this.head;
        // Удалить головной узел
        this.head = null;
        // Уменьшить длину списка
        this.length--;
        
        // Вернуть значение удалённого узла
        return deletedNode.value;
      }
      // 4.2. Если удаляется первый узел, после которого есть узел
      if (count === index && count === 0 && currentNode.next !== null) {
        // Сохранить удаляемый узел
        deletedNode = this.head;
        // Головным сделать следующий узел
        this.head = currentNode.next;
        // Уменьшить длину списка
        this.length--;

        // Вернуть значение удалённого узла
        return deletedNode.value;
      }
      // 4.3. Если удаляется НЕ первй узел, после которого нет узла
      else if (count === index && count > 0 && currentNode.next === null) {
        // Сохранить удаляемый узел
        deletedNode = currentNode;
        // У предыдущего элемента удалить ссылку "next"
        prevNode.next = null;
        // Уменьшить длину списка
        this.length--;

        // Вернуть значение удалённого узла
        return deletedNode.value;
      }
      // 4.4. Если удаляется НЕ первй узел, после которого нет узла
      else if (count === index && count > 0 && currentNode.next !== null) {
        // Сохранить удаляемый узел
        deletedNode = currentNode;
        // У предыдущего элемета задать ссылку на следующий элемент
        prevNode.next = currentNode.next;
        // Уменьшить длину списка
        this.length--;

        // Вернуть значение удалённого узла
        return deletedNode.value;
      }

      // 5. Если ничего не совпало
      // 5.1. Текущий узел сделать предыдущим
      prevNode = currentNode;
      // 5.2. Следующий узел сделать текущим
      currentNode = currentNode.next;
      // 5.3. Увеличить счётчик на 1
      count++;
    }
  }

  // ===================================================================
  // Заменить значение узла в указанной позиции
  // ===================================================================
  replace(index, value) {
    // 1. Если список пустой
    if (this.head === null) {
      // 1.1. Нечего искать, поэтому вернуть "null"
      return undefined;
    }
    
    // 2. Если список не пустой
    // 2.1. Головной объект сделать текущим
    let currentNode = this.head;
    // 2.2. Счётчик узлов. Начальное значение
    let count = 0;

    // 3.1. Пока счётчик меньше нужного индекса
    while (count <= index) {
      // 3.2. Если счётчик дошёл до искомого индекса, заменить значение
      if (count === index) currentNode.value = value;

      // 3.3. Если у текущего элемента нет ссылки на следующий узел, значит
      // 3.4. ... закончились узлы, не дойдя до нужного индекса
      if (currentNode.next === null) return undefined;
      
      // 3.5. Сделать следующий узел текущим (пока не дойдёт до нужного индекса)
      currentNode = currentNode.next;
      // 3.6. Увеличить индекс на 1
      count++;
    }
  }


  // ===================================================================
  // Вернуть массив узлов
  // ===================================================================
  toArray() {
    // 1. Если список пустой, вернуть пустой массив
    if (this.isEmpty) {
      return [];
    }

    // 2. Переменные
    // 2.1. Массив, в который будут добавляться значения узлов
    const nodesArr = [];
    // 2.2. "Головной" узел сделать "текущим", так как с него начинается перебор
    let currentNode = this.head;

    // 3. Пока очередной текущий узел существует (не равен "null")
    while (currentNode !== null) {
      // 3.1. Добавить узел в массив
      nodesArr.push(currentNode);
      // 3.2. "Следующий" узел сделать "текущим"
      currentNode = currentNode.next;
    }

    // 3. Вернуть массив значений узлов
    return nodesArr.map(item => item.value);
  }


  // ===================================================================
  // Сортировать узлы списка
  // ===================================================================
  sort(sortFunc) {
    // 1. Если список пустой, вернуть пустой массив
    if (this.isEmpty) {
      return [];
    }

    // Преобразовать в массив и отсортировать
    const sortedArray = [...this.toArray()].sort(sortFunc);
    // Очистить список
    this.clear();
    // Добавить в список узлы с указанным значением
    sortedArray.forEach(value => this.append(value));
  }

  // ===================================================================
  // Итерирование
  // ===================================================================
  [Symbol.iterator]() {
    const entries = this.toArray();
    let index = 0;

    return {
      next() {
        const result = {
          value: entries[index],
          done: index >= entries.length
        };

        index++;

        return result;
      }
    }
  }
}

const list = new SinglyLinkedList();
list.append(1)
console.log( list.toArray() );