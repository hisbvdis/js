# Рекурсивная проверка на чётность

## Подготовка
**Задача**
- Проверить, является ли переданное число чётным

**Описание принципа**
- Положительные числа будут сводиться к "0" или "1", уменьшаясь на 2 (чтобы сохранить чётность)
- Для отрицательных чисел будет меняться знак на противоположный, чтобы число стало положительным


## Реализация
**1. Обработка простейшего случая (без вложенного вызова)**
- Случай №1:
  - `Какой случай считается простейшим:` если "n" равно "0"
  - `Действия в простейшем случае`: нет
  - `Что возвращает простейший случай:` true (0 — чётное число)
- Случай №2:
  - `Какой случай считается простейшим:` если "n" равно "1"
  - `Действия в простейшем случае`: нет
  - `Что возвращает простейший случай:` false (1 — нечётное число)

**2. Обработка сложного случая (с вложенным вызовом)**
- Случай №1:
  - `Какой случай считается сложным`: если "n" < "0" (отрицательное число)
  - `Как упрощается значение при вложенном вызове функции:` подставляется число с обратным знаком, чтобы число стало положительным
  - `Действия в сложном случае:` нет
  - `Что возвращает сложный случай:` результат вложенного вызова функции
- Случай №2:
  - `Какой случай считается сложным`: все остальные случаи (то есть, когда "n" > 1)
  - `Как упрощается значение при вложенном вызове функции:` подставляется число, уменьшенное на 2
  - `Действия в сложном случае:` нет
  - `Что возвращает сложный случай:` результат вложенного вызова функции